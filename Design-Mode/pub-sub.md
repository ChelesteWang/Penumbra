# 发布-订阅模式

> 又叫观察者模式，定义了对象之间一对多的依赖关系。双向数据绑定了解下。

在异步编程中具有广泛应用！

解耦！尤其是新的订阅者与发布者！

DOM上绑定过事件吧？

还可以自定义事件嗷！记不记得之前写过的那个实现on off的类

> 其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。

解决方案：一个统一的全局Event对象！起到一个类似中介者的作用（Vue的new Bus()？）



必须先订阅再发布吗？应当将暂时没有订阅者的消息储存起来，当出现了第一个订阅者时可以选择将这条信息送达给订阅者？

>为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 QQ 的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。

实现就不放了，做一下扩展。

实际上和观察者模式是有区别的，观察者，顾名思义订阅者即观察者，这里没有中央事件总线，而发布订阅模式指的是希望接收通知的对象（Subscriber）基于一个主题通过自定义事件订阅主题，被激活事件的对象（Publisher）通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。



同样的，观察者模式中订阅了同一个发布者的观察者被通知后只能执行一个特定的更新方法。而发布订阅者模式则可以基于不同的主题执行不同自定义事件



发布订阅模式也是有缺点的，创建订阅者本身就需要消耗内存啥的，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到起的时候，要跟踪一个 bug 不是件轻松的事情。